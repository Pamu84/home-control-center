## Home Control Center — Copilot Instructions

Short, actionable notes to help AI assistants be productive in this repo.

- Project type: Node.js + Express backend serving a small SPA in `public/`.
- Key runtime commands: `npm install`, `node energyPrices.js` (seed prices), `npm start` (production), `npm run dev` (nodemon).

Architecture & data flow (big picture):
- Backend: `server.js` serves static UI and exposes REST endpoints used by front-end and Shelly devices. Scheduled jobs (node-cron) fetch prices and check device status.
- Price ingestion: `energyPrices.js` fetches Nord Pool (Elering) day-ahead prices, converts to 15-min slots (96/day), applies a tax multiplier (1.255) and stores result in `prices.json`.
- Device control: `shellyController.js` contains network calls to Shelly devices (IPs defined in `config.js`). Shelly devices run a local script (`shellyScript.js` generated by `shellyController`) and pull their config from `/api/config/:id`.
- Control logic: `controlLogic.js` contains scheduling logic (computeSchedule / applyShellyControl) and decides ON/OFF per timeslot based on settings.
- Frontend: `public/js/*.js` modules read `/api/prices` and per-device settings, render charts with Chart.js, and call `/api/control` and `/api/save-settings`.

Important files to reference when making changes:
- `server.js` — REST endpoints, cron schedules, camera handlers.
- `energyPrices.js` — how prices are fetched & processed to 15-min slots and saved to `prices.json`.
- `shellyController.js` — how device IPs are defined and how HTTP calls to devices are made (timeouts, endpoints, error handling).
- `shellyScript.js` — Shelly-side logic; devices expect `/api/config/:id` response shape and POST heartbeat at `/api/heartbeat/:id`.
- `controlLogic.js` — algorithm for cheapest slots, min/max price overrides, slotsPerPeriod mapping (15min/30min/1hour).
- `public/js/settings.js` — settings management: loading, saving, and syncing device settings.
- `public/js/chart.js` — chart rendering and data visualization for price and state charts.
- `public/js/deviceControl.js` — device control operations and status updates.
- `public/js/ui.js` — UI initialization and management.
- `settings_<id>.json` — per-device persistent settings (same folder as server). Example: `settings_1.json`.

Conventions and notable patterns (repo-specific):
- Time granularity: canonical unit is 15-minute slots (96 slots/day). `timeFrame` values map to slotsPerPeriod: "15min"=1, "30min"=2, "1hour"=4. Many functions expect arrays sized to 96 (prices) or 96 booleans (schedule).
- Prices: stored in `prices.json` as { today: [...96 slots], tomorrow: [...96 slots] } with each slot { time, price }. energyPrices converts API values using `price/10 * 1.255` (to c/kWh with tax).
- Settings persistence: settings are saved to `./settings_<id>.json` (server uses these files directly). Use that pattern when adding config UI or syncing logic.
- Shelly integration: device registry is `shellyDevices` in `config.js`. Add new devices by adding an entry there and creating corresponding `settings_<id>.json` and UI elements in `public/index.html`.
- Server constants: `SERVER_IP`, `SERVER_PORT` in `config.js` are used by both server and generated Shelly scripts — keep them consistent and reachable by devices.
- Error handling: network calls to Shelly devices use axios with timeouts (5s). Follow that pattern for reliability.

API examples and shapes (copy-paste friendly):
- GET /api/prices -> returns JSON { today: [{time,price},...], tomorrow: [...] }
- GET /api/config/:id -> returns config used by Shelly devices; contains: deviceId, minPrice, maxPrice, numCheapest, timeFrame, manualOverride, fallbackHours (24), prices (first 96), schedule (96), lastUpdated
- POST /api/control -> body { id, action } where action is `'on'|'off'|'clear'` (server.js expects POST JSON)
- POST /api/save-settings -> body { id, settings } writes `./settings_<id>.json`
- POST /api/sync-rules -> body { id, rules } writes `./settings_<id>.json` (used to push rules to device)

Developer workflows & quick checks:
- Install dependencies: `npm install` (see `package.json`).
- Seed prices for dev: `node energyPrices.js` (creates `prices.json` so UI and /api/prices return data).
- Start server: `npm start` or `npm run dev` (nodemon).
- Test endpoints:
  * Prices: curl -s http://localhost:3000/api/prices | jq .
  * Device config (id=1): curl -s http://localhost:3000/api/config/1 | jq .
  * Control: curl -X POST http://localhost:3000/api/control -H 'Content-Type: application/json' -d '{"id":"1","action":"on"}'

Integration & external deps to note:
- Elering API: `https://dashboard.elering.ee/api/nps/price` used by `energyPrices.js` — failures are tolerated by zero-filling slots.
- Shelly devices: use their HTTP/Script APIs. Shelly Script on device relies on `HTTP.GET`/`HTTP.POST` to the server and registers `control` and `status` endpoints.
- ffmpeg / fluent-ffmpeg: camera endpoints in `server.js` use ffmpeg; recordings require local ffmpeg binary.

Testing and validation hints (project-specific):
- Ensure `prices.json` has at least ~48 non-zero prices before assuming real data; many modules validate this.
- When changing scheduling logic, validate with sample `prices.json` and `settings_<id>.json` and call `GET /api/config/:id` to inspect produced `schedule` array (length 96).
- Changing `shellyController` network calls: keep axios timeouts and return informative errors — server depends on that for marking device offline.

Small examples extracted from the codebase:
- computeSchedule logic roots: see `controlLogic.js` (uses slotsPerPeriod, sorts averages to find cheapest slots, applies min/max overrides).
- Shelly script expectations: `shellyScript.js` expects `config.prices` length >=96 and `config.schedule` length==96 and will fall back to `fallbackHours` when prices are missing.

If something is unclear or you want this condensed into a checklist for a PR template, tell me which area (API, Shelly integration, price ingestion, or UI) and I'll produce a focused version.

## Concrete snippets (copy/paste)

- Price conversion (in `energyPrices.js`):

  price_c_per_kWh = api_point.price / 10 * 1.255

- timeFrame -> slots mapping (used across `controlLogic.js`, `server.js`, `public/js/*.js`):

  "15min" => slotsPerPeriod = 1 (96 slots/day)
  "30min" => slotsPerPeriod = 2 (48 slots/day)
  "1hour" => slotsPerPeriod = 4 (24 slots/day)

- Expected `/api/config/:id` shape (server -> Shelly):

  {
    deviceId: "1",
    minPrice: 0.05,
    maxPrice: 0.20,
    numCheapest: 4,
    timeFrame: "15min",
    manualOverride: false,
    fallbackHours: [false,...(24 items)],
    prices: [/* first 96 prices (today) */],
    schedule: [/* 96 booleans */],
    lastUpdated: "2025-10-27T12:34:56.789Z"
  }

- Shelly Script expectations (from `shellyScript.js`): `config.prices.length >= 96` and `config.schedule.length == 96`. If invalid, device will fall back to `fallbackHours`.

- Useful curl examples:

  curl -s http://localhost:3000/api/prices | jq .

  curl -s http://localhost:3000/api/config/1 | jq .

  curl -X POST http://localhost:3000/api/control -H 'Content-Type: application/json' -d '{"id":"1","action":"on"}'

  curl -X POST http://localhost:3000/api/sync-rules -H 'Content-Type: application/json' -d '{"id":"1","rules":{"minPrice":0.05}}'

## PR checklist (small, reproducible checks)

1. Run dependencies and start server

```bash
npm install
node energyPrices.js   # seed ./prices.json for dev
npm start              # or npm run dev
```

2. Smoke tests
- GET `/api/prices` returns JSON with `today` array length 96.
- GET `/api/config/:id` returns `prices` length >= 96 and `schedule` length == 96.
- POST `/api/save-settings` writes `settings_<id>.json` and subsequent GET `/api/load-settings?id=<id>` returns the saved values.

3. Device / network checks (if devices available)
- Confirm `config.js` contains correct IPs for `shellyDevices` and `SERVER_IP`/`SERVER_PORT` match server.
- Use `GET /api/shelly-status/:id` to verify communication.

4. Code-level checks
- When changing price or schedule logic, add/modify a unit test that validates `computeSchedule` or `applyShellyControl` behaviour with a sample `prices` array.
- Ensure any new network calls use axios with a 5s timeout pattern used in `shellyController.js`.

5. Documentation
- Update `README.md` if the change affects runtime commands, config variables, or the Shelly script contract.

---

If you want, I can also add a tiny test harness that runs `computeSchedule` against `prices.json` and asserts schedule length and some sample expected slots — shall I add that as a follow-up?
